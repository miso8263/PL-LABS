import org.scalatest._
import jsy.lab3.ast._
import Lab3._

class FunctionCallSpec extends FlatSpec {

  "Functions" should "be considered values" in {
    val f = "f"
    val x = "x"
    val e1 = Function(None, x, Var(x))
    val e2 = Function(Some(f), x, Var(x))
    assert(evaluate(e1) == e1)
    assert(evaluate(e2) == e2)
  } 
  
  "Call" should "evaluate a function using big-step semantics" in {
    val f = "f"
    val x = "x"
    val e1 = Function(None, x, Binary(Plus, Var(x), N(1)))
    val e2 = N(2)
    val e3 = evaluate(Call(e1, e2))
    assert(e3 === N(3))
  }

  "Call" should "handle recursive functions using big-step semantics" in {
    val f = "f"
    val x = "x"
    val fbody = If(Binary(Eq, Var(x), N(0)), Var(x), Binary(Plus, Var(x), Call(Var(f), Binary(Minus, Var(x), N(1)))))
    val e1 = Function(Some(f), x, fbody)
    val e2 = N(3)
    val e3 = evaluate(Call(e1, e2))
    assert(e3 === N(6))
  } 

  
  "Call" should "evaluate a function using small-step semantics" in {
    val f = "f"
    val x = "x"
    val e1 = Function(None, x, Binary(Plus, Var(x), N(1)))
    val e2 = N(2)
    val e3 = iterateStep(Call(e1, e2))
    assert(e3 === N(3))
  }

  "Call" should "handle recursive functions using small-step semantics" in {
    val f = "f"
    val x = "x"
    val fbody = If(Binary(Eq, Var(x), N(0)), Var(x), Binary(Plus, Var(x), Call(Var(f), Binary(Minus, Var(x), N(1)))))
    val e1 = Function(Some(f), x, fbody)
    val e2 = N(3)
    val e3 = iterateStep(Call(e1, e2))
    assert(e3 === N(6))
  } 
  
  "Test Case" should "act differently in small- vs. big-step" in {
	val f = "f"
	val x = "x"
	val foobody = ConstDecl(f, Binary(Plus, Var(x), N(5)), Var(f))
	val e1 = Function(None, x, foobody)
	val barbody = ConstDecl(x, N(5), Var(x))
	val e2 = Function(None, x, barbody)
	val e5 = ConstDecl(x, N(5), Var(x))
	
	val e3 = iterateStep(Call(e1, e5))
	val e4 = iterateStep(Call(e2, e5))
	val e6 = evaluate(Call(e1, e5))
	val e7 = evaluate(Call(e2, e5))
	
	println(e3)
	println(e4)
	println(e6)
	println(e7)
  } 
}
